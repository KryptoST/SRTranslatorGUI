<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.ComponentModel.Composition</name>
    </assembly>
    <members>
        <member name="P:System.SR.ArgumentException_EmptyString">
            <summary>'{0}' cannot be an empty string ("").</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidEnum">
            <summary>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</summary>
        </member>
        <member name="P:System.SR.ArgumentValueType">
            <summary>The argument was a value type which is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_AssemblyReflectionOnly">
            <summary>'{0}' is a reflection-only assembly which is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_NullElement">
            <summary>'{0}' cannot contain a null (Nothing in Visual Basic) element.</summary>
        </member>
        <member name="P:System.SR.AssemblyFileNotFoundOrWrongType">
            <summary>Assembly file {0} is either not found or not a dll or exe file.</summary>
        </member>
        <member name="P:System.SR.CardinalityMismatch_NoExports">
            <summary>No exports were found that match the constraint: {0}</summary>
        </member>
        <member name="P:System.SR.CardinalityMismatch_TooManyExports_Constraint">
            <summary>More than one export was found that matches the constraint: {0}</summary>
        </member>
        <member name="P:System.SR.ImportEngine_ComposeTookTooManyIterations">
            <summary>The composition failed because it did not complete within '{0:N0}' iterations. This is most likely caused by a cycle in the dependency graph of a part which is marked with a non-shared creation policy.</summary>
        </member>
        <member name="P:System.SR.ContractMismatch_ExportedValueCannotBeCastToT">
            <summary>Cannot cast the underlying exported value of type '{0}' to type '{1}'.</summary>
        </member>
        <member name="P:System.SR.DirectoryNotFound">
            <summary>Directory '{0}' could not be found.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_PartConstructorThrewException">
            <summary>An exception occurred while trying to create an instance of type '{0}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ExportThrewException">
            <summary>An exception occurred while trying to get the value of property '{0}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_PartOnImportsSatisfiedThrewException">
            <summary>An exception occurred while calling the 'OnImportsSatisfied' method on type '{0}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportThrewException">
            <summary>An exception occurred while trying to set the value of property '{0}'.</summary>
        </member>
        <member name="P:System.SR.ExportDefinitionNotOnThisComposablePart">
            <summary>{0} did not originate from the ExportDefinitions property on this ComposablePart or its ComposablePartDefinition.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionNotWritable">
            <summary>Cannot populate the collection '{0}' because it does not implement ICollection&lt;T&gt; or is read-only. If the collection is not IEnumerable&lt;T&gt; or T[] it must implement ICollection&lt;T&gt; and be either pre-initialized or be writable with a default constructor.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionNull">
            <summary>Cannot populate the value of enumerable member '{0}' because it is null (Nothing in Visual Basic). If the collection is not IEnumerable&lt;T&gt; or T[] it must implement ICollection&lt;T&gt; and be either pre-initialized or be writable with a default constructor.</summary>
        </member>
        <member name="P:System.SR.ImportEngine_PartCycle">
            <summary>Cannot compose part '{0}' because a cycle exists in the dependencies between the exports being composed. To break this cycle, consider changing some imports from constructor to property injection.</summary>
        </member>
        <member name="P:System.SR.ImportDefinitionNotOnThisComposablePart">
            <summary>{0} did not originate from the ImportDefinitions property on this ComposablePart or its ComposablePartDefinition.</summary>
        </member>
        <member name="P:System.SR.ImportNotSetOnPart">
            <summary>Could not finishing composing object of type '{0}'. The import '{1}' was not satisfied.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportNotWritable">
            <summary>Cannot set the value of '{0}' because the member is not writable. If the member is a property, it must have an accessible setter; otherwise, if it is a field, it must not be read-only.</summary>
        </member>
        <member name="P:System.SR.InternalExceptionMessage">
            <summary>Internal error occurred. Additional information: '{0}'.</summary>
        </member>
        <member name="P:System.SR.InvalidMetadataView">
            <summary>The Type '{0}' supplied is not a valid Metadata View.</summary>
        </member>
        <member name="P:System.SR.InvalidOperationReentrantCompose">
            <summary>A call to Compose occurred during a call to Compose on the same CompositionContainer object. Use the IsComposing property on CompositionContainer to ensure a composition is not already in progress before calling Compose.</summary>
        </member>
        <member name="P:System.SR.MetadataItemNotSupported">
            <summary>This export does not support the metadata item '{0}'.</summary>
        </member>
        <member name="P:System.SR.NotSupportedInterfaceMetadataView">
            <summary>Interface '{0}' is not a valid MetadataView; MetadataViews do not support non-public interfaces, and interfaces that contain members that are not properties.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_PartConstructorMissing">
            <summary>Cannot create an instance of type '{0}' because a constructor could not be selected for construction. Ensure that the type either has a default constructor, or a single constructor marked with the 'System.ComponentModel.Composition.ImportingConstructorAttr ...</summary>
        </member>
        <member name="P:System.SR.NotImplemented_NotOverriddenByDerived">
            <summary>The {0} member must be overridden by a derived class.</summary>
        </member>
        <member name="P:System.SR.NotSupportedReadOnlyDictionary">
            <summary>The underlying dictionary is read-only.</summary>
        </member>
        <member name="P:System.SR.ObjectAlreadyInitialized">
            <summary>This property cannot be set after the object's public surface has been accessed.</summary>
        </member>
        <member name="P:System.SR.ObjectMustBeInitialized">
            <summary>This object has not been initialized - the property '{0}' must be set.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportNotAssignableFromExport">
            <summary>The export '{0}' is not assignable to type '{1}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ExportNotReadable">
            <summary>Cannot get the value of property '{0}', because the member is not readable. The property must have an accessible getter.</summary>
        </member>
        <member name="P:System.SR.Argument_ElementReflectionOnlyType">
            <summary>'{0}' contains a reflection-only type which is not supported.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_DefinitionCannotBeRecomposed">
            <summary>'definition' cannot be set after Activate has been called because ImportDefinition.IsRecomposable is false.</summary>
        </member>
        <member name="P:System.SR.Argument_ExportsEmpty">
            <summary>'exports' cannot be empty when ImportDefinition.ImportCardinality is ImportCardinality.ExactlyOne.</summary>
        </member>
        <member name="P:System.SR.Argument_ExportsTooMany">
            <summary>'exports' cannot contain more than one element when ImportDefinition.ImportCardinality is ImportCardinality.ZeroOrOne or ImportCardinality.ExactlyOne.</summary>
        </member>
        <member name="P:System.SR.CompositionElement_UnknownOrigin">
            <summary>Unknown Origin</summary>
        </member>
        <member name="P:System.SR.ImportEngine_PartCannotActivate">
            <summary>Cannot activate part '{0}'.</summary>
        </member>
        <member name="P:System.SR.ImportEngine_PartCannotSetImport">
            <summary>Cannot set import '{0}' on part '{1}'.</summary>
        </member>
        <member name="P:System.SR.ImportEngine_PartCannotGetExportedValue">
            <summary>Cannot get export '{0}' from part '{1}'.</summary>
        </member>
        <member name="P:System.SR.TypeCatalog_Empty">
            <summary>&lt;Empty&gt;</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_GetExportedValueBeforePrereqImportSet">
            <summary>GetExportedValue cannot be called before prerequisite import '{0}' has been set.</summary>
        </member>
        <member name="P:System.SR.CompositionException_ErrorPrefix">
            <summary>Resulting in:</summary>
        </member>
        <member name="P:System.SR.CompositionException_MultipleErrorsWithMultiplePaths">
            <summary>The composition produced multiple composition errors, with {0:N0} root causes. The root causes are provided below.</summary>
        </member>
        <member name="P:System.SR.CompositionException_ReviewErrorProperty">
            <summary>Review the CompositionException.Errors property for more detailed information.</summary>
        </member>
        <member name="P:System.SR.CompositionException_SingleErrorWithMultiplePaths">
            <summary>The composition produced a single composition error, with {0:N0} root causes. The root causes are provided below.</summary>
        </member>
        <member name="P:System.SR.CompositionException_SingleErrorWithSinglePath">
            <summary>The composition produced a single composition error. The root cause is provided below.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionGetThrewException">
            <summary>Cannot populate the collection '{0}' because an exception occurred while trying to access the collection value. If the collection is not IEnumerable&lt;T&gt; or T[] it must implement ICollection&lt;T&gt; and be either pre-initialized or be writable with a default cons ...</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionAddThrewException">
            <summary>Cannot populate the collection '{0}' because an exception occurred while calling the Add method on the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionClearThrewException">
            <summary>Cannot populate the collection '{0}' because an exception occurred while calling the Clear method on the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionIsReadOnlyThrewException">
            <summary>Cannot populate the collection '{0}' because an exception occurred while reading the IsReadOnly property on the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportCollectionConstructionThrewException">
            <summary>Cannot populate the collection '{0}' because an exception occurred while calling the default constructor on the type '{1}'.</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Discovery_MemberMarkedWithMultipleImportAndImportMany">
            <summary>The member or parameter '{0}' is marked with multiple Import and ImportMany attributes. Only the first attribute encountered will be respected.</summary>
        </member>
        <member name="P:System.SR.Discovery_MetadataContainsValueWithInvalidType">
            <summary>Property '{0}' has type '{1}' which is an invalid metadata type. Metadata can only contain values with a type that is available to be embedded at compile-time into attributes. For more details of what types are valid reference section 17.1.3 in the C# spec ...</summary>
        </member>
        <member name="P:System.SR.Discovery_DuplicateMetadataNameValues">
            <summary>Member or Type '{0}' contains multiple metadata entries with the name '{1}'. The metadata entries could be coming from the ExportMetadataAttribute or from a property of a custom metadata attribute. Either remove the duplicate entries or enable the metadata ...</summary>
        </member>
        <member name="P:System.SR.Discovery_ReservedMetadataNameUsed">
            <summary>Member or Type '{0}' contains a metadata entry with the name '{1}', which is a reserved metadata key name. Either remove this metadata entry or change the name associated with the entry.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_InvalidExportDefinition">
            <summary>ExportDefinition of type '{0}' cannot be used in this context. Only export definitions produced by the ReflectionModelServices.CreateExportDefinition are supported.</summary>
        </member>
        <member name="P:System.SR.ImportEngine_PreventedByExistingImport">
            <summary>Change in exports prevented by non-recomposable import '{0}' on part '{1}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_InvalidImportDefinition">
            <summary>ImportDefinition of type '{0}' cannot be used in this context. Only import definitions produced by the ReflectionModelServices.CreateImportDefinition are supported.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_InvalidPartDefinition">
            <summary>ComposablePartDefinition of type '{0}' cannot be used in this context. Only part definitions produced by the ReflectionModelServices.CreatePartDefinition are supported.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidEnumInSet">
            <summary>The value of argument '{0}' ({1}) is not supported. Allowed values are : '{2}'.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_InvalidMemberImportDefinition">
            <summary>ImportDefinition of type '{0}' cannot be used in this context. Only import definitions produced by the ReflectionModelServices.CreateImportDefinition based on members are supported. Use ReflectionModelServices.IsImportingParameter to determine whether a gi ...</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_InvalidParameterImportDefinition">
            <summary>ImportDefinition of type '{0}' cannot be used in this context. Only import definitions produced by the ReflectionModelServices.CreateImportDefinition based on parameters are supported. Use ReflectionModelServices.IsImportingParameter to determine whether a ...</summary>
        </member>
        <member name="P:System.SR.LazyMemberInfo_AccessorsNull">
            <summary>Accessors must not be null (Nothing in Visual Basic).</summary>
        </member>
        <member name="P:System.SR.LazyMemberInfo_InvalidAccessorOnSimpleMember">
            <summary>A member of type '{0}' must have exactly a single accessor of type '{0}'</summary>
        </member>
        <member name="P:System.SR.LazyMemberinfo_InvalidEventAccessors_AccessorType">
            <summary>All event accessors must be methods.</summary>
        </member>
        <member name="P:System.SR.LazyMemberInfo_InvalidEventAccessors_Cardinality">
            <summary>An event must have exactly three accessors.</summary>
        </member>
        <member name="P:System.SR.LazyMemberinfo_InvalidPropertyAccessors_AccessorType">
            <summary>All property accessors must be methods.</summary>
        </member>
        <member name="P:System.SR.LazyMemberInfo_InvalidPropertyAccessors_Cardinality">
            <summary>A property must have exactly two accessors.</summary>
        </member>
        <member name="P:System.SR.LazyMemberInfo_NoAccessors">
            <summary>A member must have at least one accessor.</summary>
        </member>
        <member name="P:System.SR.LazyServices_LazyResolvesToNull">
            <summary>The lazily evaluated value of type '{0}' passed to the ReflectionModelServices API as part of the argument '{1}' must not return null (Nothing in Visual Basic).</summary>
        </member>
        <member name="P:System.SR.InvalidMetadataValue">
            <summary>Metadata can only contain values with a type that is available to be embedded at compile-time into attributes. For more details of what types are valid reference section 17.1.3 in the C# specification.</summary>
        </member>
        <member name="P:System.SR.ContractMismatch_InvalidCastOnMetadataField">
            <summary>Unable to create an Instance of the Metadata view '{0}' because the exporter exported the metadata  for the item '{1}' with the value '{2}' as type '{3}' but the view imports it as type '{4}'.</summary>
        </member>
        <member name="P:System.SR.ContractMismatch_NullReferenceOnMetadataField">
            <summary>Unable to create an Instance of the Metadata view '{0}' because the exporter exported the metadata for the item '{1}' with a null value and null is not a valid value for type '{2}'.</summary>
        </member>
        <member name="P:System.SR.InvalidSetterOnMetadataField">
            <summary>The MetadataView '{0}' is invalid because property '{1}' has a property set method.</summary>
        </member>
        <member name="P:System.SR.CompositionException_ChangesRejected">
            <summary>The composition remains unchanged. The changes were rejected because of the following error(s): {0}</summary>
        </member>
        <member name="P:System.SR.ImportEngine_InvalidStateForRecomposition">
            <summary>The ComposablePart of type '{0}' cannot be recomposed because it is in an invalid state. It can only be recomposed if it has already been fully previewed or composed.</summary>
        </member>
        <member name="P:System.SR.AtomicComposition_AlreadyCompleted">
            <summary>The atomicComposition can no longer be changed because the atomicComposition has already been completed.</summary>
        </member>
        <member name="P:System.SR.AtomicComposition_PartOfAnotherAtomicComposition">
            <summary>The atomicComposition contains another inner atomicComposition and cannot be changed until the that inner atomicComposition has been completed.</summary>
        </member>
        <member name="P:System.SR.AtomicComposition_AlreadyNested">
            <summary>The atomicComposition already contains an inner atomicComposition and cannot contain more than one atomicComposition at a time.</summary>
        </member>
        <member name="P:System.SR.ReentrantCompose">
            <summary>Currently composing another batch in this ComposablePartExportProvider. Only one batch can be composed at a time.</summary>
        </member>
        <member name="P:System.SR.ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned">
            <summary>The importing constructor on type '{0}' is using ImportManyAttribute on parameter '{1}' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable&lt;T&gt;.</summary>
        </member>
        <member name="P:System.SR.CompositionException_ElementPrefix">
            <summary>Element: {0}</summary>
        </member>
        <member name="P:System.SR.CompositionException_OriginSeparator">
            <summary>--&gt;</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Rejection_DefinitionRejected">
            <summary>The ComposablePartDefinition '{0}' has been rejected. {1}</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Rejection_DefinitionResurrected">
            <summary>The ComposablePartDefinition '{0}' that was previously rejected has been resurrected.</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Discovery_AssemblyLoadFailed">
            <summary>The catalog '{0}' could not load assembly '{1}'. {2}</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Discovery_DefinitionContainsNoExports">
            <summary>The ComposablePartDefinition '{0}' was ignored because it contains no exports.</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute">
            <summary>The ComposablePartDefinition '{0}' was ignored because it was marked with PartNotDiscoverableAttribute.</summary>
        </member>
        <member name="P:System.SR.CompositionException_MetadataViewInvalidConstructor">
            <summary>Unable to create an instance of the Metadata view '{0}' because a constructor could not be selected.  Ensure that the type implements a constructor which takes an argument of type IDictionary&lt;string, object&gt;.</summary>
        </member>
        <member name="P:System.SR.CompositionException_PathsCountSeparator">
            <summary>)</summary>
        </member>
        <member name="P:System.SR.CompositionException_OriginFormat">
            <summary>{0} {1}</summary>
        </member>
        <member name="P:System.SR.TypeCatalog_DisplayNameFormat">
            <summary>{0} (Types='{1}').</summary>
        </member>
        <member name="P:System.SR.ImportNotValidOnIndexers">
            <summary>Import is not valid on an Indexer property.  The import '{0}' was not satisfied.</summary>
        </member>
        <member name="P:System.SR.ExportNotValidOnIndexers">
            <summary>Export is not valid on an Indexer property.  The export '{0}' was not retrieved.</summary>
        </member>
        <member name="P:System.SR.ReflectionContext_Requires_DefaultConstructor">
            <summary>A ReflectionContext must have a default constructor.</summary>
        </member>
        <member name="P:System.SR.ReflectionContext_Type_Required">
            <summary>The type specified in the ReflectionContextDiscoveryAttribute must be assignable to System.Reflection.ReflectionContext.</summary>
        </member>
        <member name="P:System.SR.CompositionTrace_Discovery_DefinitionMismatchedExportArity">
            <summary>The composable part definition '{0}' was ignored because the export '{1}' has different generic parameters than the part type.</summary>
        </member>
        <member name="P:System.SR.InvalidArgument_ReflectionContext">
            <summary>'reflectionContext' must be a type that is assignable from System.Reflection.ReflectionContext.</summary>
        </member>
        <member name="P:System.SR.Argument_ReflectionContextReturnsReflectionOnlyType">
            <summary>'{0}' returns a mapped type that is a reflection-only type which is not supported.</summary>
        </member>
        <member name="P:System.SR.ContractMismatch_MetadataViewImplementationDoesNotImplementViewInterface">
            <summary>Unable to create an Instance of the Metadata view '{0}' because the implementation class : '{0}' does not implement the MetadataView interface '{1}'.</summary>
        </member>
        <member name="P:System.SR.ContractMismatch_MetadataViewImplementationCanNotBeNull">
            <summary>The implementation type for the MetadataView '{0} can not be null.</summary>
        </member>
        <member name="P:System.SR.InvalidPartCreationPolicyOnImport">
            <summary>A CreationPolicy of '(0)' can not be applied to an Import that is not an ExportFactory.</summary>
        </member>
        <member name="P:System.SR.ExportFactory_TooManyGenericParameters">
            <summary>ExportFactory subclass '{0}' can not have more than two generic parameters.</summary>
        </member>
        <member name="P:System.SR.CatalogMutation_Invalid">
            <summary>ScopingPolicyCatalog does not support catalog mutation.</summary>
        </member>
        <member name="P:System.SR.NotSupportedCatalogChanges">
            <summary>This CompositionService does not support catalog changes.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_RevertAndCompleteActionsMustNotThrow">
            <summary>AtomicComposition encountered an unexpected Exception, review InnerException for details.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ComponentModel_Composition">
            <summary>System.ComponentModel.Composition APIs are not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.Expecting_AtleastOne_Type">
            <summary>Expecting genericTypeArguments to contain at least one Type</summary>
        </member>
        <member name="P:System.SR.Expecting_Empty_Queue">
            <summary>Expecting genericTypeArguments queue to be empty.</summary>
        </member>
        <member name="P:System.SR.Expecting_Generic_Type">
            <summary>Expecting type to be a generic type</summary>
        </member>
        <member name="P:System.SR.Diagnostic_InternalExceptionMessage">
            <summary>Internal error occurred. Additional information: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Diagnostic_TraceUnnecessaryWork">
            <summary>To avoid unnecessary work when a trace level has not been enabled, check CanWriteXXX before calling this method.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>
